AnyType
=======

The ``AnyType`` class represents runtime introspectable types for empty, scalar, structured or array
values. Objects of this type respect value semantics and can easily be passed or returned by value.

.. contents::
   :local:

Architecture
------------

To support value semantics, the design is based on a single concrete ``AnyType`` class that contains
polymorphic implementations for the different types supported (scalar, array, etc.)

The following figure shows the relevant part of the class diagram.

.. image:: /images/AnyType_classes.png

Although largely an implementation detail, the underlying ``ITypeData`` of an ``AnyType`` object is
never shared between different objects. This prevents nasty surprises when using these objects in a
multithreaded environment.

Construction
------------

Typically, ``AnyType`` objects are created in one of two ways:

* Statically: they are encoded directly by the programmer.
* Dynamically: the types are runtime generated by parsing some other data structure.

To accomodate for these different use cases, the ``AnyType`` class provides different options to
create a specific type object.

Empty type
^^^^^^^^^^

The empty type is provided as a default null type, meaning that corresponding values do not contain
any data.

Empty types can be created by copying a global constant object ``EmptyType`` or by using the default
``AnyType`` constructor::

   // Use the globally defined (const) EmptyType:
   auto empty_type = EmptyType;

   // Use default constructor to create an empty type:
   AnyType empty_type{};

Scalar types
^^^^^^^^^^^^

Scalar types provide the elementary building blocks of all ``AnyType`` objects. Their
corresponding value objects contain a single arithmetic type (including booleans) or a
string.

Similar to the empty type, scalar types can be constructed in one of two ways.

They can be directly copied from a constant global ``AnyType`` object::

   // Create a boolean type:
   auto bool_type = Boolean;

The ``AnyType.h`` header currently defines the following global constant scalar type objects (the
numbers in the identifiers refer to the bit length of the corresponding values)::

   extern const AnyType Boolean;
   extern const AnyType Character8;
   extern const AnyType SignedInteger8;
   extern const AnyType UnsignedInteger8;
   extern const AnyType SignedInteger16;
   extern const AnyType UnsignedInteger16;
   extern const AnyType SignedInteger32;
   extern const AnyType UnsignedInteger32;
   extern const AnyType SignedInteger64;
   extern const AnyType UnsignedInteger64;
   extern const AnyType Float32;
   extern const AnyType Float64;
   extern const AnyType String;

Alternatively, scalar types can be constructed by passing a ``TypeCode`` enumerator, denoting the
scalar type, to the constructor::

   // Create an unsigned 16-bit integer type:
   AnyType uint16_type(TypeCode::UInt16);

The following scalar type enumerators are supported:

.. enumerator:: TypeCode::Bool

   Boolean type, corresponding to ``true``/``false`` values.

.. enumerator:: TypeCode::Char8

   8-bit character (undefined signedness)

.. enumerator:: TypeCode::Int8
.. enumerator:: TypeCode::Int16
.. enumerator:: TypeCode::Int32
.. enumerator:: TypeCode::Int64

   Signed integer types with the given number of bits.

.. enumerator:: TypeCode::UInt8
.. enumerator:: TypeCode::UInt16
.. enumerator:: TypeCode::UInt32
.. enumerator:: TypeCode::UInt64

   Unsigned integer types with the given number of bits.

.. enumerator:: TypeCode::Float32
.. enumerator:: TypeCode::Float64

   Floating point types with 32 and 64 bits respectively.

.. enumerator:: TypeCode::String

   Type representing character strings.

Array types
^^^^^^^^^^^

Array types represent fixed size arrays of values of the same type. The provided element type is not
allowed to be empty. These are constructed using a dedicated constructor::

   // Create array type containing 20 boolean values and provide a name:
   AnyType my_bool_array(20, Boolean, "TwentyBooleans");

The last argument of this constructor is optional and if not provided, the typename will be an empty
string.

Structured types
^^^^^^^^^^^^^^^^

Structured types are key to providing flexible types that are composed of simpler ones. Contrary to
array types, they can contain different subtypes. This allows users to compose any kind of nested
structure, with the only restriction that the leaf types need to be scalar (empty types are not
allowed as leafs).

A structured type can be constructed by adding subtypes to an originally empty structure. This step
by step construction is mainly meant to support runtime construction. The following example shows
how this is achieved::

   // Create simple structured type containing:
   // - an account name of type String
   // - an account number of type UnsignedInteger64
   // - an activated flag of type Boolean
   auto account_type = EmptyStructType("AccountType");
   account_type.AddMember("AccountName", String);
   account_type.AddMember("AccountNumber", UnsignedInteger64);
   account_type.AddMember("Activated", Boolean);

Although the example showed only the addition of scalar members/subtypes, the only restriction is
that member types need to be ``AnyType`` objects. As a result, one can create structures of
structures, structures of arrays, arrays of structures, etc.

To facilitate the static creation of structured types, a dedicated constructor can be used that
accepts a braced-init-list of pairs of member names and types. This constructor also allows to
provide a name for the type, which then needs to be passed as a final optional argument to the
constructor::

   // Create a customer type that contains:
   // - a name (String)
   // - an address structure, containing:
   //   - a street field (String)
   //   - a number field (UnsignedInteger16)
   //   - a city field (String)
   // And provide a type name: "CustomerType".
   AnyType customer_type{{
     {"name", String},
     {"address", {
       {"street", String},
       {"number", UnsignedInteger16},
       {"city", String}
     }}
   }, "CustomerType"};

Copy and move
-------------

The ``AnyType`` class provides copy and move constructors and assignment operators that behave as
one would expect from objects with value semantics. There is no restriction on assigning another
``AnyType`` object to an already existing one. This implies that the underlying types are always
overwritten.

The following example shows this behavior::

   // Create a boolean type:
   auto my_type = Boolean;

   // Create an array of 5 signed integers:
   AnyType my_array(5, SignedInteger32);

   // Overwrite the first type. Afterwards, my_type encodes an array of 5 signed integers.
   my_type = my_array;

Query methods
-------------

The ``AnyType`` API contains a number of methods for querying specific information about the type.
These are listed here.

.. function:: TypeCode AnyType::GetTypeCode() const

   Retrieve the typecode enumerator for this object.

   :return: TypeCode enumerator.

   Besides the scalar type enumerators listed above, there exist three additional enumerators:

.. enumerator:: TypeCode::Empty

   Enumerator for the empty type.

.. enumerator:: TypeCode::Struct

   Enumerator for a structured type.

.. enumerator:: TypeCode::Array

   Enumerator for an array type.

.. function:: std::string GetTypeName() const

   Retrieve the type name.

   :return: Type name.

.. function:: bool AnyType::HasMember(const std::string& name) const

   Check the presence of a member type with the given name. Returns ``false`` when the current type
   is not a structured type.

   :param name: Member name to search for.
   :return: ``true`` when a direct member with the given name exists.

.. function:: std::vector<std::string> AnyType::MemberNames() const

   Return an ordered list of all direct member names.

   :return: List of member names.

.. function:: std::size_t AnyType::NumberOfMembers() const

   Retrieve the number of direct members. This is always zero for non-structured types.

   :return: Number of direct members for structured types and zero otherwise.

.. function:: AnyType AnyType::ElementType() const

   Retrieve the ``AnyType`` object corresponing to the array elements.

   :return: Type of elements in this array type.
   :throws InvalidOperationException: When current type is not an array type.

.. function:: std::size_t AnyType::NumberOfElements() const

   Retrieve the number of elements in the array. Returns zero when the current type is not an
   array type.

   :return: Number of elements for an array type and zero otherwise.

Element access
--------------

The ``AnyType`` class overloads the index operators to provide a natural way to access element types
of a structured type. Since array types have only one single type associated to their elements, no
dedicated overload exists (see :func:`AnyType::ElementType()`).

The overloaded operators are:

.. function:: AnyType& operator[](std::string fieldname)

   Try to retrieve a reference to the member that is identified by the fieldname. This fieldname
   can describe non-direct members by encoding the navigation to deeper lying members. A dot (``.``)
   is used to separate individual names of structure members, while an empty set of square brackets
   (``[]``) is used to access the element type for array types.

   :param fieldname: String encoding the path to a specific underlying type.
   :return: ``AnyType`` object if member type was found.
   :throws KeyNotAllowedException: For types that do not support element access (empty or
      scalar types) or for fieldnames that cannot be correctly parsed/interpreted (wrong format
      or unknown key).

.. function:: const AnyType& operator[](std::string fieldname) const

   Const version of the previous operator overload.

Modifier methods
----------------

The ``AnyType`` API currently contains only one method for modification, which applies only
to structured types:

.. function:: AnyType& AddMember(const std::string& name, const AnyType& type)

   Add a member type for this structured type with the given name and type. Empty types are
   not allowed as member types.

   :param name: Member name to use.
   :param type: ``AnyType`` object for the member type.
   :return: Reference to ``this`` to allow chaining such calls.
   :throws InvalidOperationException: If this operation is not supported
      (not a structured type or trying to add an empty type).
   :throws DuplicateKeyException: When this structured type already has a field with the given
      name.

Comparison operators
--------------------

Simple comparison of ``AnyType`` objects is supported by overloading both the equality and
inequality operator:

.. function:: bool operator==(const AnyType& other) const

   :param other: Other ``AnyType`` object to compare with the current.
   :return: ``true`` when equal, ``false`` otherwise.

.. function:: bool operator!=(const AnyType& other) const

   :param other: Other ``AnyType`` object to compare with the current.
   :return: ``true`` when not equal, ``false`` otherwise.

.. note::

   Equality in the context of ``AnyType`` objects requires exact equality:

   * Empty types are only equal to other empty types.
   * Scalar types are only equal to the exact same scalar type.
   * Structured types are only equal to other structured types with the same type name, member names
     and types.
   * Array types are only equal to other array types with the same name, same element type and
     number of elements.
