AnyType
=======

The ``AnyType`` class represents runtime introspectable types for empty, scalar, structured or array
values. Objects of this type respect value semantics and can easily be passed or returned by value.

.. contents::
   :local:

Architecture
------------

To support value semantics, the design is based on a single concrete ``AnyType`` class that contains
polymorphic implementations for the different types supported (scalar, array, etc.)

The following figure shows the relevant part of the class diagram.

.. image:: /images/AnyType_classes.png

Construction
------------

Typically, ``AnyType`` objects are created in one of two ways:

* Statically: they are encoded directly by the programmer.
* Dynamically: the types are runtime generated by parsing some other data structure.

To accomodate for these different use cases, the ``AnyType`` class provides different options to
create a specific type object.

Empty type
^^^^^^^^^^

The empty type is provided as a default null type, meaning that corresponding values do not contain
any data.

Empty types can be created by copying a global constant object ``EmptyType`` or by using the default
``AnyType`` constructor::

   // Use the globally defined (const) EmptyType:
   auto empty_type = EmptyType;

   // Use default constructor to create an empty type:
   AnyType empty_type{};

Scalar types
^^^^^^^^^^^^

Scalar types provide the elementary building blocks of all ``AnyType`` objects. Their
corresponding value objects contain a single arithmetic type (including booleans) or a
string.

Similar to the empty type, scalar types can be constructed in one of two ways.

They can be directly copied from a constant global ``AnyType`` object::

   // Create a boolean type:
   auto bool_type = Boolean;

The ``AnyType.h`` header currently defines the following global constant scalar type objects (the
numbers in the identifiers refer to the bit length of the corresponding values)::

   extern const AnyType Boolean;
   extern const AnyType Character8;
   extern const AnyType SignedInteger8;
   extern const AnyType UnsignedInteger8;
   extern const AnyType SignedInteger16;
   extern const AnyType UnsignedInteger16;
   extern const AnyType SignedInteger32;
   extern const AnyType UnsignedInteger32;
   extern const AnyType SignedInteger64;
   extern const AnyType UnsignedInteger64;
   extern const AnyType Float32;
   extern const AnyType Float64;
   extern const AnyType String;

Alternatively, scalar types can be constructed by passing a ``TypeCode`` enumerator, denoting the
scalar type, to the constructor::

   // Create an unsigned 16-bit integer type:
   AnyType uint16_type(TypeCode::UInt16);

The following scalar type enumerators are supported:

.. enumerator:: TypeCode::Bool

   Boolean type, corresponding to ``true``/``false`` values.

.. enumerator:: TypeCode::Char8

   8-bit character (undefined signedness)

.. enumerator:: TypeCode::Int8
.. enumerator:: TypeCode::Int16
.. enumerator:: TypeCode::Int32
.. enumerator:: TypeCode::Int64

   Signed integer types with the given number of bits.

.. enumerator:: TypeCode::UInt8
.. enumerator:: TypeCode::UInt16
.. enumerator:: TypeCode::UInt32
.. enumerator:: TypeCode::UInt64

   Unsigned integer types with the given number of bits.

.. enumerator:: TypeCode::Float32
.. enumerator:: TypeCode::Float64

   Floating point types with 32 and 64 bits respectively.

.. enumerator:: TypeCode::String

   Type representing character strings.

Array types
^^^^^^^^^^^

Array types represent fixed size arrays of values of the same type. These are constructed using a
dedicated constructor::

   // Create array type containing 20 boolean values and provide a name:
   AnyType my_bool_array(20, Boolean, "TwentyBooleans");

The last argument of this constructor is optional and if not provided, the typename will be an empty
string.

Structured types
^^^^^^^^^^^^^^^^

Structured types are key to providing flexible types that are composed of simpler ones. Contrary to
array types, they can contain different subtypes. This allows users to compose any kind of nested
structure, with the only restriction that the leaf types need to be scalar (or empty).

A structured type can be constructed by adding subtypes to an originally empty structure. This step
by step construction is mainly meant to support runtime construction. The following example shows
how this is achieved::

   // Create simple structured type containing:
   // - an account name of type String
   // - an account number of type UnsignedInteger64
   // - an activated flag of type Boolean
   auto account_type = EmptyStructType("AccountType");
   account_type.AddMember("AccountName", String);
   account_type.AddMember("AccountNumber", UnsignedInteger64);
   account_type.AddMember("Activated", Boolean);

Although the example showed only the addition of scalar members/subtypes, the only restriction is
that member types need to be ``AnyType`` objects. As a result, one can create structures of
structures, structures of arrays, arrays of structures, etc.

To facilitate the static creation of structured types, a dedicated constructor can be used that
accepts a braced-init-list of pairs of member names and types. This constructor also allows to
provide a name for the type, which then needs to be passed as a final optional argument to the
constructor::

   // Create a customer type that contains:
   // - a name (String)
   // - an address structure, containing:
   //   - a street field (String)
   //   - a number field (UnsignedInteger16)
   //   - a city field (String)
   // And provide a type name: "CustomerType".
   AnyType customer_type{{
     {"name", String},
     {"address", {
       {"street", String},
       {"number", UnsignedInteger16},
       {"city", String}
     }}
   }, "CustomerType"};

Copy and move
-------------

The ``AnyType`` class provides copy and move constructors and assignment operators that behave as
one would expect from objects with value semantics. There is no restriction on assigning another
``AnyType`` object to an already existing one. This implies that the underlying types are always
overwritten.

The following example shows this behavior::

   // Create a boolean type:
   auto my_type = Boolean;

   // Create an array of 5 signed integers:
   AnyType my_array(5, SignedInteger32);

   // Overwrite the first type. Afterwards, my_type encodes an array of 5 signed integers.
   my_type = my_array;

Query methods
-------------

The ``AnyType`` API contains a number of methods for querying specific information about the type.
These are listed here.

.. function:: GetTypeCode() const

   Retrieve the typecode enumerator for this object. Besides the scalar type enumerators listed
   above, there exist three additional enumerators:

.. enumerator:: TypeCode::Empty

   Enumerator for the empty type.

.. enumerator:: TypeCode::Struct

   Enumerator for a structured type.

.. enumerator:: TypeCode::Array

   Enumerator for an array type.

.. function:: GetTypeName() const

   Retrieve the type name.

.. function:: HasMember(const std::string& name) const

   Check the presence of a member type with the given name. Returns ``false`` when the current type
   is not a structured type.

.. function:: MemberNames() const

   Retrieve an ordered list of all direct member names.

.. function:: NumberOfMembers() const

   Retrieve the number of direct members. This is always zero for non-structured types.

.. function:: ElementType() const

   Retrieve the ``AnyType`` object corresponing to the array elements. Throws an
   ``InvalidOperationException`` when the current type is not an array type.

.. function:: NumberOfElements() const

   Retrieve the number of elements in the array. Returns zero when the current type is not an
   array type.

Element access
--------------

The ``AnyType`` class overloads the index operators to provide a natural way to access element types
of a structured type. Since array types have only one single type associated to their elements, no
dedicated overload exists (see above).

